// compile with -t nes_small_v and -O1 (O4 is broken at the moment)

//use the dpad to move the player around
//use a to jump
//use b to attack

import nes_joy
import nes_lib
import game_lib
import metatiles
import scrolling
import physics
import sprite_manager
import anims
import enemies
import music
import levels
import platformer

byte gamestate

void init_game() {
    init_sprites()
    init_sprite_manager()
    ppu_oam_dma_write(oam_buffer.addr.hi)
    clear_status_bar()
    draw_status_bar()
    prepare_sprite0()
    reset_collis_flags()
    reset_scroll_flags()
    init_scroll_vars()
    init_enemy_heap()
    init_spawner_flags()
}

void init_game_and_load_level(byte level) {
    ppu_ctrl = %00000000   // enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    ppu_mask = %00000110   // enable sprites, enable background, no clipping on left side
    init_game()
    load_level(level)
    ppu_set_scroll(0,0)
    ppu_wait_vblank()
    ppu_ctrl = %10010000   // enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    ppu_mask = %00011110   // enable sprites, enable background, no clipping on left side
}

void main() {
    gamestate = 1 // 1 = game is playing a level
    init_game_and_load_level(0)
    new_frame = true
    while(true) {
        if gamestate == 1 {
            game_main()
        }
    }
}

void game_main() {
    while new_frame == true {
        //wait for the new frame to be drawn
    }
    if touched_goal != 0 {
        scrolling_right = false
        scrolling_left = false
        new_frame = false
        win_timer += 1
        if win_timer >= $80 {
            init_game_and_load_level(next_level)
        }
    }
    else {
        game_logic()
        if reset_level {
            init_game_and_load_level(current_level)
        }
    }
    new_frame = true
}

void nmi() {
    // use a return dispatch here
    // to use different logic for each screen/gamestate
    return [gamestate] {
        1    @ game_nmi
    }
}

void game_nmi() {
    if new_frame {
        //Do scroll handling before anything since it needs 
        //to set the scroll before the screen starts drawing
        handle_scrolling()
    }
    
    draw_health_p1()
    
    //set scroll to 0 for now so that the status bar
    //stays still
    ppu_set_scroll(0,0)
    ppu_ctrl = %00010000 // no need to or the nametable for this one,
                         // as the status bar should always be at the first nametable
    ppu_mask = %00011110
    
    //Transfer the sprites to the screen through DMA
    if new_frame {
        //NOTE: handle_scrolling sometimes takes so long that sprite DMA
        //bleeds into the drawing of the first scanline (particularly when crossing screens).  
        //For now, avoid having sprites appear at the very top of the screen and all should
        //still be well.
        ppu_oam_dma_write(oam_buffer.addr.hi)
        //update the music
        FamiToneUpdate()
        //NOTE: currently, by only updating the music
        //when there's a new frame, the music slows down
        //when the game slows down. FamiToneUpdate() can't be
        //outside of this if statement however, as when the game slows down
        //it makes function calls
        //that could blow out the stack. (When the game slows down,
        //NMI usually occurs during enemy processing, which 
        //fills up the stack with lots of function calls. This means the stack
        //is already almost full, and FamiToneUpdate's calls are sometimes enough to blow
        //it out, completely breaking the game).
        
        //This could be solved by saving enough of the stack in temporary variables
        //before calling FamiToneUpdate(), and then restoring the stack afterwords,
        //thus avoiding any stack overflows.  It might be a good idea to count the deepest
        //function call in FamiToneUpdate() so as to get a precise number of stack space
        //to save.
    }

    //first wait for the previous frame's sprite0 hit
    //to clear
   
    while (ppu_status & %01000000) != 0 {
    }
    
    //Move the music update to here,
    //once the stack blowout is solved
    
    //start checking for a sprite0 hit
    //so that we know the status bar is done drawing
    
    //then wait for this frame's sprite0 hit
    while (ppu_status & %01000000) == 0 {
    }
    
    //now wait for the end of the scanline
    wait_cycles($02)
    
    //The status bar is done drawing, so draw the rest of
    //the screen with the correct scroll values
    ppu_set_scroll(xscroll,0)
    ppu_ctrl = %10010000 | nametable
    ppu_mask = %00011110
    
    if new_frame {
        new_frame = false
    }
}

void irq() {
}

segment(chrrom) const array graphics @ $0000 = file("graphics/twin_dragons.chr")