byte nametable //current nametable
byte draw_nametable //the nametable we want to draw on
byte draw_seam_column //column at the draw/scroll seam
byte next_column      //column to be drawn to next
byte current_screen      //screen to load next
byte xscroll          //screen x scroll value
byte prev_xscroll     //previous xcroll value
bool scrolling_right
bool scrolling_left
byte previous_scroll //0 = scrolling right, 1 = scrolling left

//How many pixels before a new attribute table column
//is needed should we load them?  This is necessary because loading
//an attribute column and a tile column at the same time takes too
//much time for the nmi.
//Note: this should be changed to be greater than or equal to the max
//x velocity of the player
const byte attr_draw_offset = 8

inline void update_scroll_left() {
    prev_xscroll = xscroll
    xscroll -= scroll_speed
    
    passed_column_boundary(xscroll, prev_xscroll)
    passed_meta_column_boundary(xscroll, prev_xscroll)
    
    if xscroll > prev_xscroll {
        //we overflowed to a new screen
        current_screen -= 1
        if current_screen >= 4 {
            current_screen = 3
        }
        nametable ^= %00000001
    }
    if changed_column {
        draw_seam_column = current_screen << 5
        draw_seam_column += xscroll >> 3
    }
    
    //deal with the attribute column offset
    xscroll -= attr_draw_offset
    prev_xscroll -= attr_draw_offset
    
    if xscroll > prev_xscroll {
        changed_screen = true
        draw_nametable = nametable ^ %00000001
    }
    else {
        changed_screen = false
        draw_nametable = nametable
    }

    passed_attr_column_boundary(xscroll, prev_xscroll)
    
    xscroll += attr_draw_offset
    prev_xscroll += attr_draw_offset
}

inline void update_scroll_right() {
    prev_xscroll = xscroll
    xscroll += scroll_speed
    
    passed_column_boundary(xscroll, prev_xscroll)
    passed_meta_column_boundary(xscroll, prev_xscroll)
    
    if xscroll < prev_xscroll {
        //we overflowed to a new screen
        current_screen += 1
        if current_screen >= 4 {
            current_screen = 0
        }
        nametable ^= %00000001
        changed_screen = true
    }
    else {
        changed_screen = false
    }
    if changed_column {
        //we've passed a column boundary, update our current column
        draw_seam_column = current_screen << 5
        draw_seam_column += xscroll >> 3
    }
    
    //deal with the attribute column offset
    xscroll += attr_draw_offset
    prev_xscroll += attr_draw_offset
    
    if xscroll < prev_xscroll {
        changed_screen = true
        draw_nametable = nametable
    }
    else {
        changed_screen = false
        draw_nametable = nametable ^ %00000001
    }

    passed_attr_column_boundary(xscroll, prev_xscroll)
    
    xscroll -= attr_draw_offset
    prev_xscroll -= attr_draw_offset
}

void passed_column_boundary(byte xscroll_new, byte xscroll_old) {
    //compares the two, and then sets changed_column appropriately
    if (xscroll_new & %11111000) != (xscroll_old & %11111000) {
        changed_column = true
    }
    else {
        changed_column = false
    }
}

void passed_meta_column_boundary(byte xscroll_new, byte xscroll_old) {
    //compares the two, and then sets changed_meta_column appropriately
    if (xscroll_new & %11110000) != (xscroll_old & %11110000) {
        changed_meta_column = true
    }
    else {
        changed_meta_column = false
    }
}

void passed_attr_column_boundary(byte xscroll_new, byte xscroll_old) {
    //compares the two, and then sets changed_meta_column appropriately
    if (xscroll_new & %11100000) != (xscroll_old & %11100000) {
        changed_attr_column = true
    }
    else {
        changed_attr_column = false
    }
}


inline void left_metatile_scroll() {
    if draw_counter == 0 && changed_attr_column{
        // about to enter a 32 pixel boundary, so
        // draw the attributes
        next_column = draw_seam_column
        
        if changed_screen {
            //we've overflowed onto a new screen, so draw on the right nametable
            load_attr_column($07,draw_nametable,(next_column>>2) - 1)
        }
        else {
            load_attr_column((xscroll>>5) - 1,draw_nametable,(next_column>>2) - 1)
            //we subtract 1 from the 1st and 3rd arguments because we're loading
            //in attribute tables 1 step ahead in order to keep up with scrolling
        }
    }
    else if changed_column || draw_counter > 0 {
        // on a 16 pixel boundary, so
        // load the appropriate tiles
        next_column = draw_seam_column

        draw_column_with_counter((xscroll>>4),draw_nametable,(next_column>>1))
    }
}

inline void right_metatile_scroll() {
    // use an else-if here
    // so that we don't load attrs and tiles
    // on the same frame, as that would take
    // too much time and bleed into screen rendering
    if draw_counter == 0 && changed_attr_column {
        // about to enter a 32 pixel boundary, so
        // draw the attributes
        next_column = draw_seam_column + $20
        if next_column >= $80 {
            // if we're on the final screen, then wrap around to the beginning
            next_column -= $80
        }
        
        if (xscroll+attr_draw_offset) < (prev_xscroll+attr_draw_offset) {
            //we've overflowed onto a new screen, so draw on the right nametable
            load_attr_column((xscroll+attr_draw_offset)>>5,draw_nametable,(next_column>>2) + 1)
        }
        else {
            load_attr_column((xscroll+attr_draw_offset)>>5,draw_nametable,(next_column>>2) + 1)
            //add 1 to 3rd argument because we are loading the column that is one ahead
            //of our loading seam
        }
    }
    else if changed_meta_column || draw_counter > 0 {
        // on a 16 pixel boundary, so
        // load the appropriate tiles
        next_column = draw_seam_column + $20
        
        if next_column >= $80 {
            // if we're on the final screen, then wrap around to the beginning
            next_column -= $80
        }
        draw_column_with_counter(xscroll>>4,draw_nametable,next_column>>1)
    }
}

byte get_column_from_screenx(byte screenx) {
    byte new_column
    word new_column_offset //must be a word because (xscroll+newplayerx) can overflow
    
    new_column = current_screen << 5 //leftmost column of current screen
    new_column_offset = xscroll
    new_column_offset += screenx
    new_column_offset >>= 3
    new_column += new_column_offset.lo
    if new_column >= $80 {
       new_column -= $80
    }
    
    return new_column
}

byte get_row_from_screeny(byte screeny) {
    return screeny >> 3
}
