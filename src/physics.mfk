//collision flags
bool collis_flag
bool down_collis_flag
bool up_collis_flag
bool right_collis_flag
bool left_collis_flag

//slope flag
byte on_slope

const byte player_max_xvel = 10
const byte player_max_xvel_neg = -10
const byte player_x_friction = 8
const byte player_x_air_friction = 8
const byte player_max_yvel = 32
const byte player_max_yvel_neg = -24
const byte player_gravity_accel = 4

inline void reset_collis_flags() {
    collis_flag = false
    up_collis_flag = false
    down_collis_flag = false
    left_collis_flag = false
    right_collis_flag = false
}

bool is_collidable(byte tile) {
    if tile != $24 {
        return true
    }
    return false
}

inline void slope_check(byte tile) {
    if tile == $0A || tile == $09 {
        on_slope = 2
    }
    else if tile == $0C || tile == $0f {
        on_slope = 1
    }
    else {
        on_slope = 0
    }
}

inline void check_background_collis_down(byte screenx, byte screeny, byte spritewidth, byte spriteheight) {
    check_background_collis(screenx, screeny, spritewidth, spriteheight, 0)
}

inline void check_background_collis_up(byte screenx, byte screeny, byte spritewidth, byte spriteheight) {
    check_background_collis(screenx, screeny, spritewidth, spriteheight, 1)
}

inline void check_background_collis_right(byte screenx, byte screeny, byte spritewidth, byte spriteheight) {
    check_background_collis(screenx, screeny, spritewidth, spriteheight, 2)
}

inline void check_background_collis_left(byte screenx, byte screeny, byte spritewidth, byte spriteheight) {
    check_background_collis(screenx, screeny, spritewidth, spriteheight, 3)
}


inline void check_background_collis_horiz(byte screenx, byte screeny, byte spritewidth, byte spriteheight) {
    check_background_collis(screenx, screeny, spritewidth, spriteheight, 2)
    check_background_collis(screenx, screeny, spritewidth, spriteheight, 3)
}

inline void check_background_collis_vert(byte screenx, byte screeny, byte spritewidth, byte spriteheight) {
    check_background_collis(screenx, screeny, spritewidth, spriteheight, 0)
    check_background_collis(screenx, screeny, spritewidth, spriteheight, 1)
}

//TODO: optimize this function
void check_background_collis(byte screenx, byte screeny, byte spritewidth, byte spriteheight, byte side) {
    //check if the bounding box is colliding with collidable background tiles
    //on its left and right edges
    byte new_column1
    byte new_column2
    byte new_row1
    byte new_row2
    byte i
    byte limit
    byte current_tile
    
    //do the collision stuff, set the left and right
    //flags depending on left/right or up/down collisions

    if side == 0 {
        //DOWN SIDE
        new_row1 = get_row_from_screeny(screeny+spriteheight)
        new_column1 = get_column_from_screenx(screenx)
        new_column2 = get_column_from_screenx(screenx+spritewidth)
        
        limit = new_column2-new_column1
        i = 0
        
        while i <= limit{
            current_tile = get_tile(new_column1+i, new_row1)
            if is_collidable(current_tile) {
                collis_flag = true
                down_collis_flag = true
                return
            }
            i += 1
        }
    }
    if side == 1 {
        //UP SIDE

        new_row1 = get_row_from_screeny(screeny)
        new_column1 = get_column_from_screenx(screenx)
        new_column2 = get_column_from_screenx(screenx+spritewidth)
        
        limit = new_column2-new_column1
        i = 0
        
        while i <= limit{
            current_tile = get_tile(new_column1+i, new_row1)
            if is_collidable(current_tile) {
                collis_flag = true
                up_collis_flag = true
                return
            }
            i += 1
        }
    }
    if side == 2{
        //it is expected that the vertical
        //collision checks are done first
        
        //RIGHT SIDE
        new_column1 = get_column_from_screenx(screenx+spritewidth)
        new_row1 = get_row_from_screeny(screeny)
        new_row2 = get_row_from_screeny(screeny+spriteheight)
        
        limit = new_row2-new_row1
        i = 0

        while i <= limit{
            current_tile = get_tile(new_column1, new_row1+i)
            if is_collidable(current_tile) {
                slope_check(current_tile)
                collis_flag = true
                right_collis_flag = true
                return
            }
            i += 1
        }
        on_slope = 0
    }
    if side == 3 {
        //LEFT SIDE
        new_column1 = get_column_from_screenx(screenx)
        new_row1 = get_row_from_screeny(screeny)
        new_row2 = get_row_from_screeny(screeny+spriteheight)
        
        limit = new_row2-new_row1
        i = 0

        while i <= limit{
            current_tile = get_tile(new_column1, new_row1+i)
            if is_collidable(current_tile) {
                slope_check(current_tile)
                collis_flag = true
                left_collis_flag = true
                return
            }
            i += 1
        }
        on_slope = 0
    }
}

inline void check_still_on_slope(pointer.Phys_Obj obj_ptr) {
    if obj_ptr->yvel < 0 {
        //jumping means we're no longer on the slope
        obj_ptr->on_slope = 0
    }
    
    if obj_ptr->on_slope == 1 {
        //negative slope
    }
    else if obj_ptr->on_slope == 2 {
        //positive slope
    }
}

inline void check_player_collis_and_update_loc(pointer.Player player_ptr) {
    check_still_on_slope(pointer.Phys_Obj(player_ptr))
    
    if player_ptr->on_slope != 0 {
        update_obj_speed_on_slope(pointer.Phys_Obj(player_ptr))
        return
    }
    
    //do vertical collision checking
    obj_collis_vert(pointer.Phys_Obj(player_ptr))
    
    collis_flag = false
    
    //do horizontal collision checking
    obj_collis_horiz(pointer.Phys_Obj(player_ptr))
    
    player_ptr->on_ground = down_collis_flag
    player_ptr->on_slope = on_slope
    reset_collis_flags()
}

inline void check_obj_collis_and_update_loc(pointer.Phys_Obj obj_ptr) {
    //do vertical collision checking
    obj_collis_vert(obj_ptr)
    
    collis_flag = false
    
    //do horizontal collision checking
    obj_collis_horiz(obj_ptr)

    reset_collis_flags()
}

void obj_collis_horiz(pointer.Phys_Obj obj_ptr) {
    update_obj_x_speed(obj_ptr)

    if obj_ptr->xvel > 0 {
        check_background_collis_right(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
    }
    else if obj_ptr->xvel < 0 {
        check_background_collis_left(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
    }
    
    if collis_flag {
        obj_ptr->xvel = 0
    }
    
    //if the speed was great enough to possibly have skipped over a
    //landing point, then stick them to the wall
    if right_collis_flag {
        obj_ptr->xfrac = 0
        obj_ptr->pos.x = ((obj_ptr->pos.x + obj_ptr->pos.width) & %11111000) - obj_ptr->pos.width + (((xscroll^%00000111)+1)&%00000111) - 1
        //Got the math for this by looking at a naive implementation (basically copy-pasting the pos.y equalivalent,
        //and then seeing where things went wrong) to find a way to programatically correct those errors.  So yeah,
        //not entirely sure why this math works but it has something to with the fact that scrolling messes up tile
        //and sprite alignment.  ¯\_(ツ)_/¯
    }
    //do the same for a negative velocities
    else if left_collis_flag {
        obj_ptr->xfrac = 0
        obj_ptr->pos.x = (obj_ptr->pos.x & %11111000) - (xscroll & %00000111) + 8
    }
}

void obj_collis_vert(pointer.Phys_Obj obj_ptr) {
    update_obj_y_speed(obj_ptr)
    
    if obj_ptr->yvel > 0 {
        check_background_collis_down(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
    }
    else if obj_ptr->yvel < 0 {
        check_background_collis_up(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
    }
    
    if collis_flag{
        obj_ptr->yvel = 0
    }
    
    //if the speed was great enough to possibly have skipped over a
    //landing point, then stick them to the ground
    if down_collis_flag {
        obj_ptr->yfrac = 0
        obj_ptr->pos.y = ((obj_ptr->pos.y + obj_ptr->pos.height) & %11111000) - obj_ptr->pos.height - 1
        //(obj_ptr->y + obj_ptr->height) = farthest point that collided with the ground
        //Take that value and align it to the top of the closest 8-pixel tile boundary by
        //and-ing it with 8.  Now subtract that by obj_ptr->height since we want to have
        //it stuck to the ground and not in the ground. Subtract by one because sprites are
        //always off by one relative to the background
        //Note: this breaks if obj_ptr is moving faster than 8 pixels per frame
    }
    //do the same for a negative velocities
    else if up_collis_flag {
        obj_ptr->yfrac = 0
        obj_ptr->pos.y = (obj_ptr->pos.y & %11111000) + 8
        //each tile is 8 pixels high, if the top of the object
        //is in a tile, then align it to the tile (by and'ing by 8),
        //then jump to the next tile (that is not collidable hopefully,
        //as long as the velocity didn't exceed 8 pixels per frame).
    }
}

void update_obj_speed_on_slope(pointer.Phys_Obj obj_ptr) {
    if obj_ptr->xvel < 0{
        obj_ptr->xvel = flip_sign(obj_ptr->xvel) //obj_ptr->xvel *= -1
        obj_ptr->pos.x -= obj_ptr->xvel >> 2
        if obj_ptr->on_slope == 1 {
            obj_ptr->pos.y -= obj_ptr->xvel >> 2
        }
        else {
            obj_ptr->pos.y += obj_ptr->xvel >> 2
        }
        obj_ptr->xfrac -= obj_ptr->xvel & %00000011
        if obj_ptr->xfrac > 3 {
            obj_ptr->xfrac += 4 // 4 because 4 + -1 = 3, 4 + -2 = 2, 4 + -3 = 1, 4 + -4 = 0
                              // so basically, (max fractional part value) + 1
            obj_ptr->pos.x -= 1
            if obj_ptr->on_slope == 1 {
                obj_ptr->pos.y -= 1
            }
            else {
                obj_ptr->pos.y += 1
            }
        }
        obj_ptr->xvel = flip_sign(obj_ptr->xvel) //obj_ptr->xvel *= -1
    }
    else {
        obj_ptr->pos.x += obj_ptr->xvel >> 2
        if obj_ptr->on_slope == 1 {
            obj_ptr->pos.y += obj_ptr->xvel >> 2
        }
        else {
            obj_ptr->pos.y -= obj_ptr->xvel >> 2
        }
        obj_ptr->xfrac += obj_ptr->xvel & %00000011
        if obj_ptr->xfrac > 3 {
            obj_ptr->xfrac -= 3
            obj_ptr->pos.x += 1
            if obj_ptr->on_slope == 1 {
                obj_ptr->pos.y += 1
            }
            else {
                obj_ptr->pos.y -= 1
            }
        }
    }
}

void update_obj_x_speed(pointer.Phys_Obj obj_ptr) {
    if obj_ptr->xvel < 0{
        obj_ptr->xvel = flip_sign(obj_ptr->xvel) //obj_ptr->xvel *= -1
        obj_ptr->pos.x -= obj_ptr->xvel >> 2
        obj_ptr->xfrac -= obj_ptr->xvel & %00000011
        if obj_ptr->xfrac > 3 {
            obj_ptr->xfrac += 4 // 4 because 4 + -1 = 3, 4 + -2 = 2, 4 + -3 = 1, 4 + -4 = 0
                              // so basically, (max fractional part value) + 1
            obj_ptr->pos.x -= 1
        }
        obj_ptr->xvel = flip_sign(obj_ptr->xvel) //obj_ptr->xvel *= -1
    }
    else {
        obj_ptr->pos.x += obj_ptr->xvel >> 2
        obj_ptr->xfrac += obj_ptr->xvel & %00000011
        if obj_ptr->xfrac > 3 {
            obj_ptr->xfrac -= 3
            obj_ptr->pos.x += 1
        }
    }
}

void update_obj_y_speed(pointer.Phys_Obj obj_ptr) {
    if obj_ptr->yvel < 0{
        obj_ptr->yvel = flip_sign(obj_ptr->yvel)
        obj_ptr->pos.y -= obj_ptr->yvel >> 2
        obj_ptr->yfrac -= obj_ptr->yvel & %00000011
        if obj_ptr->yfrac > 3 {
            obj_ptr->yfrac += 4 // 4 because 4 + -1 = 3, 4 + -2 = 2, 4 + -3 = 1, 4 + -4 = 0
            obj_ptr->pos.y -= 1
        }
        obj_ptr->yvel = flip_sign(obj_ptr->yvel) // yvel *= -1
    }
    else {
        obj_ptr->pos.y += obj_ptr->yvel >> 2
        obj_ptr->yfrac += obj_ptr->yvel & %00000011
        if obj_ptr->yfrac > 3 {
            obj_ptr->yfrac -= 3
            obj_ptr->pos.y += 1
        }
    }
}
