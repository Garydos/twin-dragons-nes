//collision flags
bool collis_flag
bool down_collis_flag
bool up_collis_flag
bool right_collis_flag
bool left_collis_flag

const byte player_max_xvel = 10
const byte player_max_xvel_neg = -10
const byte player_x_friction = 8
const byte player_x_air_friction = 8
const byte player_max_yvel = 32
const byte player_max_yvel_neg = -24
const byte player_gravity_accel = 4

inline void reset_collis_flags() {
    collis_flag = false
    up_collis_flag = false
    down_collis_flag = false
    left_collis_flag = false
    right_collis_flag = false
}

bool is_collidable(byte tile) {
    if tile != $24 {
        return true
    }
    return false
}

inline void check_background_collis_horiz(byte screenx, byte screeny, byte spritewidth, byte spriteheight) {
    check_background_collis(screenx, screeny, spritewidth, spriteheight, false)
}

inline void check_background_collis_vert(byte screenx, byte screeny, byte spritewidth, byte spriteheight) {
    check_background_collis(screenx, screeny, spritewidth, spriteheight, true)
}

//TODO: optimize this function
void check_background_collis(byte screenx, byte screeny, byte spritewidth, byte spriteheight, bool vert) {
    //check if the bounding box is colliding with collidable background tiles
    //on its left and right edges
    byte new_column1
    byte new_column2
    byte new_row1
    byte new_row2
    byte i
    byte limit
    byte current_tile
    
    //do the collision stuff, set the left and right
    //flags depending on left/right or up/down collisions

    if vert {
        //DOWN SIDE
        new_row1 = get_row_from_screeny(screeny+spriteheight)
        new_column1 = get_column_from_screenx(screenx)
        new_column2 = get_column_from_screenx(screenx+spritewidth)
        
        limit = new_column2-new_column1
        i = 0
        
        while i <= limit{
            current_tile = get_tile(new_column1+i, new_row1)
            if is_collidable(current_tile) {
                collis_flag = true
                down_collis_flag = true
                return
            }
            i += 1
        }
        
        //UP SIDE

        new_row1 = get_row_from_screeny(screeny)
        new_column1 = get_column_from_screenx(screenx)
        new_column2 = get_column_from_screenx(screenx+spritewidth)
        
        limit = new_column2-new_column1
        i = 0
        
        while i <= limit{
            current_tile = get_tile(new_column1+i, new_row1)
            if is_collidable(current_tile) {
                collis_flag = true
                up_collis_flag = true
                return
            }
            i += 1
        }
    }
    else {
        //it is expected that the vertical
        //collision checks are done first
        
        //RIGHT SIDE
        new_column1 = get_column_from_screenx(screenx+spritewidth)
        new_row1 = get_row_from_screeny(screeny)
        new_row2 = get_row_from_screeny(screeny+spriteheight)
        
        limit = new_row2-new_row1
        i = 0

        while i <= limit{
            current_tile = get_tile(new_column1, new_row1+i)
            if is_collidable(current_tile) {
                collis_flag = true
                right_collis_flag = true
                return
            }
            i += 1
        }
        
        //LEFT SIDE
        new_column1 = get_column_from_screenx(screenx)
        new_row1 = get_row_from_screeny(screeny)
        new_row2 = get_row_from_screeny(screeny+spriteheight)
        
        limit = new_row2-new_row1
        i = 0

        while i <= limit{
            current_tile = get_tile(new_column1, new_row1+i)
            if is_collidable(current_tile) {
                collis_flag = true
                left_collis_flag = true
                return
            }
            i += 1
        }
    }
}

//compiler bug: If player_ptr is a parameter to check_player_collis_and_update_player_loc
//instead of being a global variable, then it is assigned the same address as other pointer
//local variables in other functions.  This means that player_ptr is overwritten by function
//calls made within the body of check_player_collis_and_update_player_loc if it's a parameter.
//The workaround is to have it as a global variable, that way no other function will touch it.
pointer.Phys_Obj obj_ptr
void check_obj_collis_and_update_loc() {
    //do vertical collision checking
    obj_collis_vert()
    
    collis_flag = false
    
    //do horizontal collision checking
    obj_collis_horiz()
    
    //leave resetting the collision flags to the calling function
}

void obj_collis_horiz() {
    update_obj_x_speed()

    check_background_collis_horiz(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
    if collis_flag {
        // playerx = old_x
        // playerx_frac = old_x_frac
        obj_ptr->xvel = 0
    }
    
    //if the speed was great enough to possibly have skipped over a
    //landing point, then stick them to the wall
    if right_collis_flag {
        obj_ptr->xfrac = 0
        do {
            collis_flag = false
            obj_ptr->pos.x -= 1
            check_background_collis_horiz(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
        } while collis_flag
    }
    //do the same for a negative velocities
    else if left_collis_flag {
        obj_ptr->xfrac = 0
        do {
            collis_flag = false
            obj_ptr->pos.x += 1
            check_background_collis_horiz(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
        }while collis_flag
    }
}

void obj_collis_vert() {
    
    update_obj_y_speed()
    
    check_background_collis_vert(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
    // obj_ptr->on_ground = down_collis_flag
    if collis_flag{   
        // playery = old_y
        // playery_frac = old_y_frac
        obj_ptr->yvel = 0
    }
    
    //if the speed was great enough to possibly have skipped over a
    //landing point, then stick them to the ground
    if down_collis_flag {
        obj_ptr->yfrac = 0
        do {
            collis_flag = false
            //player->pos.y -= 1
            obj_ptr->pos.y -= 1
            check_background_collis_vert(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
        } while collis_flag
    }
    //do the same for a negative velocities
    else if up_collis_flag {
        obj_ptr->yfrac = 0
        do {
            collis_flag = false
            obj_ptr->pos.y += 1
            check_background_collis_vert(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
        }while collis_flag
    }
}

void check_obj_collis_and_update_loc_fast() {
    //doesn't do checks for fast velocities,
    //so if you use this function instead of the regular one,
    //objects will visibly stop/slowdown next to the obstacle
    //if they're going too fast
    byte old_x
    byte old_x_frac
    byte old_y
    byte old_y_frac
    
    old_x = obj_ptr->pos.x
    old_y = obj_ptr->pos.y    
    old_x_frac = obj_ptr->xfrac
    old_y_frac = obj_ptr->yfrac
    
    //do vertical collision checking
    
    //if we're going too fast, do the collision checking in two steps
    //to ensure we stick to the ground
    
    update_obj_y_speed()
    
    check_background_collis_vert(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
    // obj_ptr->on_ground = down_collis_flag
    if collis_flag{   
        obj_ptr->pos.y = old_y
        obj_ptr->yfrac = old_y_frac
        obj_ptr->yvel = 0
    }

    collis_flag = false
    
    //do horizontal collision checking
    update_obj_x_speed()

    check_background_collis_horiz(obj_ptr->pos.x, obj_ptr->pos.y, obj_ptr->pos.width, obj_ptr->pos.height)
    if collis_flag {
        obj_ptr->pos.x = old_x
        obj_ptr->xfrac = old_x_frac
        obj_ptr->xvel = 0
    }
    
    //leave resetting the collision flags to the calling function
}


void update_obj_x_speed() {
    if obj_ptr->xvel < 0{
        obj_ptr->xvel = flip_sign(obj_ptr->xvel) //obj_ptr->xvel *= -1
        obj_ptr->pos.x -= obj_ptr->xvel >> 2
        obj_ptr->xfrac -= obj_ptr->xvel & %00000011
        if obj_ptr->xfrac > 3 {
            obj_ptr->xfrac += 4 // 4 because 4 + -1 = 3, 4 + -2 = 2, 4 + -3 = 1, 4 + -4 = 0
                              // so basically, (max fractional part value) + 1
            obj_ptr->pos.x -= 1
        }
        obj_ptr->xvel = flip_sign(obj_ptr->xvel) //obj_ptr->xvel *= -1
    }
    else {
        obj_ptr->pos.x += obj_ptr->xvel >> 2
        obj_ptr->xfrac += obj_ptr->xvel & %00000011
        if obj_ptr->xfrac > 3 {
            obj_ptr->xfrac -= 3
            obj_ptr->pos.x += 1
        }
    }
}

void update_obj_y_speed() {
    if obj_ptr->yvel < 0{
        obj_ptr->yvel = flip_sign(obj_ptr->yvel)
        obj_ptr->pos.y -= obj_ptr->yvel >> 2
        obj_ptr->yfrac -= obj_ptr->yvel & %00000011
        if obj_ptr->yfrac > 3 {
            obj_ptr->yfrac += 4 // 4 because 4 + -1 = 3, 4 + -2 = 2, 4 + -3 = 1, 4 + -4 = 0
            obj_ptr->pos.y -= 1
        }
        obj_ptr->yvel = flip_sign(obj_ptr->yvel) // yvel *= -1
    }
    else {
        obj_ptr->pos.y += obj_ptr->yvel >> 2
        obj_ptr->yfrac += obj_ptr->yvel & %00000011
        if obj_ptr->yfrac > 3 {
            obj_ptr->yfrac -= 3
            obj_ptr->pos.y += 1
        }
    }
}
