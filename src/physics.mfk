//collision flags
bool collis_flag
bool down_collis_flag
bool up_collis_flag
bool right_collis_flag
bool left_collis_flag

const byte player_max_xvel = 10
const byte player_max_xvel_neg = -10
const byte player_x_friction = 8
const byte player_x_air_friction = 8
const byte player_max_yvel = 32
const byte player_max_yvel_neg = -24
const byte player_gravity_accel = 4

struct HitBox {
    byte x,
    byte y,
    byte width,
    byte height
}

inline void reset_collis_flags() {
    collis_flag = false
    up_collis_flag = false
    down_collis_flag = false
    left_collis_flag = false
    right_collis_flag = false
}

bool is_collidable(byte tile) {
    if tile != $24 {
        return true
    }
    return false
}

macro void check_background_collis_horiz(byte screenx, byte screeny, byte spritewidth, byte spriteheight) {
    check_background_collis(screenx, screeny, spritewidth, spriteheight, false)
}

macro void check_background_collis_vert(byte screenx, byte screeny, byte spritewidth, byte spriteheight) {
    check_background_collis(screenx, screeny, spritewidth, spriteheight, true)
}

void check_background_collis(byte screenx, byte screeny, byte spritewidth, byte spriteheight, bool vert) {
    //check if the bounding box is colliding with collidable background tiles
    //on its left and right edges
    byte new_column1
    byte new_column2
    byte new_row1
    byte new_row2
    byte i
    byte limit
    byte current_tile
    
    //do the collision stuff, set the left and right
    //flags depending on left/right or up/down collisions

    if vert {
        //DOWN SIDE
        new_row1 = get_row_from_screeny(screeny+spriteheight)
        new_column1 = get_column_from_screenx(screenx)
        new_column2 = get_column_from_screenx(screenx+spritewidth)
        
        limit = new_column2-new_column1
        i = 0
        
        while i <= limit{
            current_tile = get_tile(new_column1+i, new_row1)
            if is_collidable(current_tile) {
                collis_flag = true
                down_collis_flag = true
                return
            }
            i += 1
        }
        
        //UP SIDE

        new_row1 = get_row_from_screeny(screeny)
        new_column1 = get_column_from_screenx(screenx)
        new_column2 = get_column_from_screenx(screenx+spritewidth)
        
        limit = new_column2-new_column1
        i = 0
        
        while i <= limit{
            current_tile = get_tile(new_column1+i, new_row1)
            if is_collidable(current_tile) {
                collis_flag = true
                up_collis_flag = true
                return
            }
            i += 1
        }
    }
    else {
        //it is expected that the vertical
        //collision checks are done first
        
        //RIGHT SIDE
        new_column1 = get_column_from_screenx(screenx+spritewidth)
        new_row1 = get_row_from_screeny(screeny)
        new_row2 = get_row_from_screeny(screeny+spriteheight)
        
        limit = new_row2-new_row1
        i = 0

        while i <= limit{
            current_tile = get_tile(new_column1, new_row1+i)
            if is_collidable(current_tile) {
                collis_flag = true
                right_collis_flag = true
                return
            }
            i += 1
        }
        
        //LEFT SIDE
        new_column1 = get_column_from_screenx(screenx)
        new_row1 = get_row_from_screeny(screeny)
        new_row2 = get_row_from_screeny(screeny+spriteheight)
        
        limit = new_row2-new_row1
        i = 0

        while i <= limit{
            current_tile = get_tile(new_column1, new_row1+i)
            if is_collidable(current_tile) {
                collis_flag = true
                left_collis_flag = true
                return
            }
            i += 1
        }
    }
}

void check_player_collis_and_update_player_loc() {
    sbyte temp_vel
    byte old_playerx
    byte old_playerx_frac
    byte old_playery
    byte old_playery_frac
    
    old_playerx = player1.pos.x
    old_playery = player1.pos.y    
    old_playerx_frac = player1.xfrac
    old_playery_frac = player1.yfrac
    
    //do vertical collision checking
    
    //if we're going too fast, do the collision checking in two steps
    //to ensure we stick to the ground
    
    update_player_y_speed()
    
    check_background_collis_vert(player1.pos.x, player1.pos.y, player_width, player_height)
    player1.on_ground = down_collis_flag
    if collis_flag{   
        // playery = old_playery
        // playery_frac = old_playery_frac
        player1.yvel = 0
    }
    
    //if the speed was great enough to possibly have skipped over a
    //landing point, then stick them to the ground
    if down_collis_flag {
        player1.yfrac = 0
        do {
            collis_flag = false
            player1.pos.y -= 1
            check_background_collis_vert(player1.pos.x, player1.pos.y, player_width, player_height)
        } while collis_flag
    }
    //do the same for a negative velocities
    else if up_collis_flag {
        player1.yfrac = 0
        do {
            collis_flag = false
            player1.pos.y += 1
            check_background_collis_vert(player1.pos.x, player1.pos.y, player_width, player_height)
        }while collis_flag
    }
    
    collis_flag = false
    
    //do horizontal collision checking
    update_player_x_speed()

    check_background_collis_horiz(player1.pos.x, player1.pos.y, player_width, player_height)
    if collis_flag {
        // playerx = old_playerx
        // playerx_frac = old_playerx_frac
        player1.xvel = 0
    }
    
    //if the speed was great enough to possibly have skipped over a
    //landing point, then stick them to the wall
    if right_collis_flag {
        player1.xfrac = 0
        do {
            collis_flag = false
            player1.pos.x -= 1
            check_background_collis_vert(player1.pos.x, player1.pos.y, player_width, player_height)
        } while collis_flag
    }
    //do the same for a negative velocities
    else if left_collis_flag {
        player1.xfrac = 0
        do {
            collis_flag = false
            player1.pos.x += 1
            check_background_collis_vert(player1.pos.x, player1.pos.y, player_width, player_height)
        }while collis_flag
    }
    
    reset_collis_flags()
}


void update_player_x_speed() {
    if player1.xvel < 0{
        player1.xvel = flip_sign(player1.xvel) //player1.xvel *= -1
        player1.pos.x -= player1.xvel >> 2
        player1.xfrac -= player1.xvel & %00000011
        if player1.xfrac > 3 {
            player1.xfrac += 4 // 4 because 4 + -1 = 3, 4 + -2 = 2, 4 + -3 = 1, 4 + -4 = 0
                              // so basically, (max fractional part value) + 1
            player1.pos.x -= 1
        }
        player1.xvel = flip_sign(player1.xvel) //player1.xvel *= -1
    }
    else {
        player1.pos.x += player1.xvel >> 2
        player1.xfrac += player1.xvel & %00000011
        if player1.xfrac > 3 {
            player1.xfrac -= 3
            player1.pos.x += 1
        }
    }
}

void update_player_y_speed() {
    if player1.yvel < 0{
        player1.yvel = flip_sign(player1.yvel)
        player1.pos.y -= player1.yvel >> 2
        player1.yfrac -= player1.yvel & %00000011
        if player1.yfrac > 3 {
            player1.yfrac += 4 // 4 because 4 + -1 = 3, 4 + -2 = 2, 4 + -3 = 1, 4 + -4 = 0
            player1.pos.y -= 1
        }
        player1.yvel = flip_sign(player1.yvel) // yvel *= -1
    }
    else {
        player1.pos.y += player1.yvel >> 2
        player1.yfrac += player1.yvel & %00000011
        if player1.yfrac > 3 {
            player1.yfrac -= 3
            player1.pos.y += 1
        }
    }
}
