// compile with -t nes_small_v and -O4

//use the dpad to move the player around
//use a to jump
//use b to dash

import nes_joy
import nes_lib
import metatile_draw
import metatile_scroll
import physics
import sprite_manager
import players

const byte right_screen_limit = $F0
const byte left_screen_limit = $08
const byte up_screen_limit = $20
const byte down_screen_limit = $D0
byte scroll_speed

void main() {
    init_sprites()
    load_palletes()
    clear_status_bar()
    draw_status_bar()
    prepare_sprite0()
    init_player1($78, $60)
    reset_collis_flags()
    reset_scroll_flags()
    init_scroll_vars()
    
    current_level_tiles = screen_metatiles
    current_level_attrs = attrs
    max_screen = 3 // 4 screens
    
    load_screen(0)
    
    ppu_set_scroll(0,0)
    ppu_wait_vblank()
    ppu_ctrl = %10010000   // enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    ppu_mask = %00011110   // enable sprites, enable background, no clipping on left side

    while(true) {}
}

void nmi() {
    //Do scroll handling before anything since it needs 
    //to set the scroll before the screen starts drawing
    handle_scrolling()
    
    //set scroll to 0 for now so that the status bar
    //stays still
    ppu_set_scroll(0,0)
    ppu_ctrl = %10010000 // no need to or the nametable for this one,
                         // as the status bar should always be at the first nametable
    ppu_mask = %00011100
    
    //Transfer the sprites to the screen through DMA
    
    //NOTE: handle_scrolling sometimes takes so long that sprite DMA
    //bleeds into the drawing of the first scanline (particularly when crossing screens).  
    //For now, avoid having sprites appear at the very top of the screen and all should
    //still be well.
    ppu_oam_dma_write(oam_buffer.addr.hi)
    
    //TODO: famitone is probably fast enough to run in the time
    //it takes for the status bar to be drawn, so try placing it
    //here
    
    //wait for status bar drawing to be done
    status_bar_wait()
    
    //The status bar is done drawing, so draw the rest of
    //the screen with the correct scroll values
    ppu_set_scroll(xscroll,0)
    ppu_ctrl = %10010000 | nametable
    ppu_mask = %00011100
    
    game_logic()
}

void irq() {
}

void load_screen(byte screen_num) {
    current_screen = screen_num
    draw_full_screen(screen_num)
}

inline void game_logic() {
    //game logic goes here
    handle_player_input()
    cap_player_vel()
    
    check_player_collis_and_update_player_loc()
    
    apply_player_frict()
    prepare_scrolling()
    snap_player_pos_limits()
    update_player1_anim()
}

inline void status_bar_wait() {
    //start checking for a sprite0 hit
    //so that we know the status bar is done drawing
    
    //first wait for the previous frame's sprite0 hit
    //to clear
    while (ppu_status & %01000000) != 0 {
    }
    
    //then wait for this frame's sprite0 hit
    while (ppu_status & %01000000) == 0 {
    }
    
    //now wait for the end of the scanline
    wait_cycles($10)
}

inline void handle_scrolling() {
    //either scrolling right or have a column to finish drawing
    if scrolling_right || (previous_scroll == 0 && draw_counter > 0) {
        
        //update the scroll variable
        if scrolling_right{
            update_scroll_right()
        }
        
        right_metatile_scroll()
        
        previous_scroll = 0
    }
    //either scrolling left or have a column to finish drawing
    else if scrolling_left || (previous_scroll == 1 && draw_counter > 0) {
        //left scroll logic
        
        if scrolling_left {
            update_scroll_left()
        }
        
        left_metatile_scroll()
    
        previous_scroll = 1
    }
}

macro void playerx_apply_accel() {
    if (player1.xaccel >> 2) < player1.xspeed {
        //if we're less than the maximum acceleration,
        //then continually add acceleration
        player1.xaccel += 1
    }
    else {
        //if we're equal to or grater than the maximum
        //acceleration, then clamp it to the max
        player1.xaccel = player1.xspeed << 2
    }
}

macro void playery_apply_gravity() {
    player1.yaccel = player_gravity_accel
    player1.yvel += player1.yaccel
    player1.jumping = false
}

inline void handle_player_dash() {
    if input_b != 0 {
        player1.xspeed = 7
    }
    else {
        player1.xspeed = 5
    }
}

inline void handle_player_x_input() {
    if input_dx > 0 {
        if player1.pos.x < right_screen_limit {
            playerx_apply_accel()
            player1.xvel += (player1.xaccel >> 2)
        }
    }
    else if input_dx < 0 {
        if player1.pos.x > left_screen_limit {
            playerx_apply_accel()
            player1.xvel -= (player1.xaccel >> 2)
        }
    }
    else {
        scrolling_left = false
        scrolling_right = false
        player1.xaccel = 0
    }
}

inline void handle_player_y_input() {
    if input_a != 0 {
        if player1.can_jump {
            player1.yvel = 0
            player1.yaccel = 8
            player1.jumping = true
            player1.can_jump = false
        }
        if player1.yaccel < 24 && player1.jumping {
            player1.yaccel += 2
            player1.yvel -= (player1.yaccel >> 2)
        }
        else {
            playery_apply_gravity()
        }
    }
    else {
        playery_apply_gravity()
        if player1.on_ground {
            player1.can_jump = true
        }
    }
}

inline void handle_player_input() {
    read_joy1()
    
    handle_player_dash()
    handle_player_x_input()
    handle_player_y_input()
}

inline void cap_player_vel() {
    //cap velocity
    if player1.xvel >= player_max_xvel {
        player1.xvel = player_max_xvel
        player1.xfrac = 0
    }
    if player1.xvel <= player_max_xvel_neg {
        player1.xvel = player_max_xvel_neg
        player1.xfrac = 0
    }    
    
    if player1.yvel >= player_max_yvel {
        player1.yvel = player_max_yvel
        player1.yfrac = 0
    }
    if player1.yvel <= player_max_yvel_neg {
        player1.yvel = player_max_yvel_neg
        player1.yfrac = 0
    }
}

inline void apply_player_frict() {
    //apply friction
    if player1.xvel < 0 {
        player1.xvel += player_x_friction
        if player1.xvel > 0 {
            player1.xvel = 0
        }
    }
    else if player1.xvel > 0 {
        player1.xvel -= player_x_friction
        if player1.xvel < 0 {
            player1.xvel = 0
        }
    }
}

inline void prepare_scrolling() {
    //prepare the scrolling info for the next frame
    //based on the player's movements
    if player1.pos.x > scroll_right_boundary && not(current_screen == max_screen && xscroll == 0) {
        //update the position of the screen sprites
        scroll_speed = player1.pos.x - scroll_right_boundary
        //fix scroll_speed so that we never overshoot the right scroll limit
        if current_screen == (max_screen-1) && (scroll_speed + xscroll) < xscroll {
            scroll_speed = ($FF - xscroll) + 1
        }
        player1.pos.x -= scroll_speed
        //scroll the screen as well
        scrolling_right = true
        scrolling_left = false
    }
    else if player1.pos.x < scroll_left_boundary && not(current_screen == 0 && xscroll == 0) {
        //update the position of the screen sprites
        scroll_speed = scroll_left_boundary - player1.pos.x
        if current_screen == 0 && (xscroll - scroll_speed) > xscroll {
            scroll_speed = xscroll
        }
        //set screen scroll left limit
        player1.pos.x += scroll_speed
        //scroll the screen as well
        scrolling_right = false
        scrolling_left = true
    }
    else {
        scrolling_left = false
        scrolling_right = false
    }
}


inline void snap_player_pos_limits() {
    //snap the player back to the playable area of the screen
    if player1.pos.x > right_screen_limit {
        player1.pos.x = right_screen_limit
    }
    if player1.pos.x < left_screen_limit {
        player1.pos.x = left_screen_limit
    }
    if player1.pos.y > down_screen_limit {
        player1.pos.y = down_screen_limit
        player1.on_ground = true
    }
    if player1.pos.y < up_screen_limit {
        player1.pos.y = up_screen_limit
    }
}

void draw_status_bar() {
    //draw the status bar accross both nametables
    byte i
    
    //set ppu address increment to 1 so we can draw the left and right borders
    //(allows us to draw to the nametable in vertical strips rather than horizontal)
    ppu_ctrl = %00000000
    read_ppu_status()
    
    //write to first nametable
    ppu_set_addr(ppu_nametable0+$40)
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($11) //$11 = 'H'
    ppu_write_data($0E) //$0E = 'E'
    ppu_write_data($0A) //$0A = 'A'
    ppu_write_data($15) //$15 = 'L'
    ppu_write_data($1D) //$1D = 'T'
    ppu_write_data($11) //$11 = 'H'
    ppu_write_data($25) //$25 = colon
    ppu_write_data($34) //$34 = full box
    ppu_write_data($34) //$34 = full box
    ppu_write_data($35) //$35 = empty box
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($26) //$26 = lives icon
    ppu_write_data($27) //$26 = multiply icon
    ppu_write_data($03) //$03 = 3
    
    //write to second nametable
    ppu_set_addr(ppu_nametable1+$40)
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($11) //$11 = 'H'
    ppu_write_data($0E) //$0E = 'E'
    ppu_write_data($0A) //$0A = 'A'
    ppu_write_data($15) //$15 = 'L'
    ppu_write_data($1D) //$1D = 'T'
    ppu_write_data($11) //$11 = 'H'
    ppu_write_data($25) //$25 = colon
    ppu_write_data($34) //$34 = full box
    ppu_write_data($34) //$34 = full box
    ppu_write_data($35) //$35 = empty box
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($26) //$26 = lives icon
    ppu_write_data($27) //$26 = multiply icon
    ppu_write_data($03) //$03 = 3
    
    
}

void clear_status_bar() {
    //clear the status bar to all sky tiles
    byte i
    
    //set ppu address increment to 1 so we can draw the left and right borders
    //(allows us to draw to the nametable in vertical strips rather than horizontal)
    ppu_ctrl = %00000000
    read_ppu_status()
    
    ppu_set_addr(ppu_nametable0)
    for i,0,until,$80 {
        ppu_write_data($24) //$24 = sky tile
    }
    
    ppu_set_addr(ppu_nametable1)
    for i,0,until,$80 {
        ppu_write_data($24) //$24 = sky tile
    }
}

void load_palletes() {
    byte i
    read_ppu_status() // read PPU status to reset the high/low latch
    ppu_set_addr(ppu_pallete_ram) // point the PPU to palette ram
    for i,0,until,$20 {
        ppu_write_data(pallete[i])
    }
}

const array pallete = [
  $0F,$17,$18,$29,$34,$38,$18,$2A,$38,$39,$3A,$3B,$3C,$3D,$3E,$0F, //nametable palettes
  $3C,$10,$37,$0F,$07,$10,$2D,$0F,$0F,$00,$0F,$36,$31,$02,$38,$3C  //sprite palettes
]

//define each metatile
const array metatiles = [
			//Tile positions:
			//top-left	bot-left	top-right	bot-right
            $24,		$24,		$24,		$24, // 		$00, should always be
                                                     //        all background
            $30,		$31,		$30,		$31, // 		$01, basic top ground tile
            $31,		$31,		$31,		$31, //		$02, all ground tile
            $24,		$32,		$24,		$24, //		$03, floor flower tile
            $24,		$24,		$24,		$33, //		$04, floor grass tile
            $24,		$36,		$24,		$37, //		$05, bushes tile A
            $24,		$30,		$24,		$24 //		$06, single-tile platform
]


//contains 4 screens worth of metatiles
//each metatile column is 16 bytes long
//each metatile column contains 3 bytes of wasted space, two at the top, and one at end
//(this is a holdover from one of my older projects, you could rearange it so that all
//the unused bytes are contiguous, you'd just have to change the loops in the draw_column functions)
const array screen_metatiles = file("levels/level1.bin")

const array attrs = file("graphics/attrib.bin")

segment(chrrom) const array graphics @ $0000 = file("graphics/nesthing.chr")