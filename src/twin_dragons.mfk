// compile with -t nes_small_v and -O4

//use the dpad to move the player around
//use a to jump
//use b to dash

//TODO: rework scrolling so that it works even
//if you skip over the specific xscroll values it needs
//to detect a new column

import nes_joy
import nes_lib
import metatile_draw
import metatile_scroll
import physics

array oam_buffer [256] @$200 // sprite buffer

//constant offsets for oam_buffer
//so we can draw the player metasprite easily,
//in a real game you should use a oam manager
const byte playersprite0_x = 4
const byte playersprite0_tile = 5
const byte playersprite0_attrs = 6
const byte playersprite0_y = 7

const byte playersprite1_x = 8
const byte playersprite1_tile = 9
const byte playersprite1_attrs = 10
const byte playersprite1_y = 11

const byte playersprite2_x = 12
const byte playersprite2_tile = 13
const byte playersprite2_attrs = 14
const byte playersprite2_y = 15

const byte playersprite3_x = 16
const byte playersprite3_tile = 17
const byte playersprite3_attrs = 18
const byte playersprite3_y = 19

//player sprite constants
const byte sprite0_attrs = 0
const byte sprite1_attrs = 0
const byte sprite2_attrs = 0
const byte sprite3_attrs = 0
const byte sprite0_tile = 0
const byte sprite1_tile = 1
const byte sprite2_tile = 2
const byte sprite3_tile = 3

void main() {
    init_sprites()
    load_palletes()
    clear_status_bar()
    draw_status_bar()
    prepare_sprite0()
    
    xscroll = 0
    nametable = 0
    draw_seam_column = 0
    draw_counter = 0
    previous_scroll = 0
    current_screen = 0
    playerx = 10
    playery = $60
    playerx_speed = 8
    scroll_speed = 2
    playerx_accel = 0
    playery_accel = 0
    scrolling_right = false
    scrolling_left = false
    collis_flag = false
    down_collis_flag = false
    up_collis_flag = false
    right_collis_flag = false
    left_collis_flag = false
    changed_column = false
    changed_meta_column = false
    changed_attr_column = false
    changed_screen = false
    on_ground = false
    jumping = false
    can_jump = true
    
    //screen 1 + screen 2 leftmost column
    draw_full_screen(0,0)
    draw_column(0,1,16)
    load_attr_column(0,0,0)
    load_attr_column(1,0,1)
    load_attr_column(2,0,2)
    load_attr_column(3,0,3)
    load_attr_column(4,0,4)
    load_attr_column(5,0,5)
    load_attr_column(6,0,6)
    load_attr_column(7,0,7)
    load_attr_column(0,1,8)
    
    ppu_set_scroll(0,0)
    ppu_wait_vblank()
    ppu_ctrl = %10010000   // enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    ppu_mask = %00011110   // enable sprites, enable background, no clipping on left side

    while(true) {}
}

void nmi() {
    ppu_oam_dma_write(oam_buffer.addr.hi)
    
    //either scrolling right or have a column to finish drawing
    if scrolling_right || (previous_scroll == 0 && draw_counter > 0) {
        
        //update the scroll variable
        if scrolling_right{
            update_scroll_right()
        }
        
        right_metatile_scroll()
        
        previous_scroll = 0
    }
    //either scrolling left or have a column to finish drawing
    else if scrolling_left || (previous_scroll == 1 && draw_counter > 0) {
        //left scroll logic
        
        if scrolling_left {
            update_scroll_left()
        }
        
        left_metatile_scroll()
    
        previous_scroll = 1
    }
    
    //set scroll to 0 for now so that the status bar
    //stays still
    ppu_set_scroll(0,0)
    ppu_ctrl = %10010000 // no need to or the nametable for this one,
                         // as the status bar should always be at the first nametable
    ppu_mask = %00011100
    
    //now we start checking for a sprite0 hit
    //so that we know the status bar is done drawing
    
    //first wait for the previous frame's sprite0 hit
    //to clear
    while (ppu_status & %01000000) != 0 {
    }
    
    //then wait for this frame's sprite0 hit
    while (ppu_status & %01000000) == 0 {
    }
    
    //now wait for the end of the scanline
    wait_cycles($10)
    
    //we have now reached the end of the scanline, and the
    //status bar is done drawing, so draw the rest of
    //the screen with the correct scroll values
    ppu_set_scroll(xscroll,0)
    ppu_ctrl = %10010000 | nametable
    ppu_mask = %00011100
    
    game_logic()
}

inline void game_logic() {
    //game logic goes here
    read_joy1()
    
    if input_b != 0 {
        playerx_speed = 7
    }
    else {
        playerx_speed = 5
    }
    
    if input_dx > 0 {
        // scrolling_right = true
        // scrolling_left = false
        if playerx < $F0 {
            if (playerx_accel >> 2) < playerx_speed {
                playerx_accel += 1
            }
            else {
                playerx_accel = playerx_speed << 2
            }
            // playerxvel += playerx_speed
            playerxvel += (playerx_accel >> 2)
        }
    }
    else if input_dx < 0 {
        // scrolling_right = false
        // scrolling_left = true
        if playerx > $08 {
            if (playerx_accel >> 2) < playerx_speed {
                playerx_accel += 1
            }
            else {
                playerx_accel = playerx_speed << 2
            }
            // playerxvel -= playerx_speed
            playerxvel -= (playerx_accel >> 2)
        }
    }
    else {
        scrolling_left = false
        scrolling_right = false
        playerx_accel = 0
    }
    
    if input_a != 0 {
        if can_jump {
            playeryvel = 0
            playery_accel = 8
            jumping = true
            can_jump = false
        }
        if playery_accel < 24 && jumping {
            playery_accel += 2
            playeryvel -= (playery_accel >> 2)
        }
        else {
            playery_accel = player_gravity_accel
            playeryvel += playery_accel
            jumping = false
        }
    }
    else {
        // scrolling_right = false
        // scrolling_left = true
        playery_accel = player_gravity_accel
        playeryvel += playery_accel
        jumping = false
        if on_ground {
            can_jump = true
        }
    }
    
    
    //cap velocity
    if playerxvel >= player_max_xvel {
        playerxvel = player_max_xvel
        playerx_frac = 0
    }
    if playerxvel <= player_max_xvel_neg {
        playerxvel = player_max_xvel_neg
        playerx_frac = 0
    }    
    
    if playeryvel >= player_max_yvel {
        playeryvel = player_max_yvel
        playery_frac = 0
    }
    if playeryvel <= player_max_yvel_neg {
        playeryvel = player_max_yvel_neg
        playery_frac = 0
    }
    
    check_player_collis_and_update_player_loc()
    
    //apply friction
    if playerxvel < 0 {
        playerxvel += player_x_friction
        if playerxvel > 0 {
            playerxvel = 0
        }
    }
    else if playerxvel > 0 {
        playerxvel -= player_x_friction
        if playerxvel < 0 {
            playerxvel = 0
        }
    }
    
    if playerx > $78 && not(current_screen == 3 && xscroll == 0) {
        // playerx = $78
        //update the position of the screen sprites
        scroll_speed = playerx - $78
        //fix scroll_speed so that we never overshoot the right scroll limit
        if current_screen == 2 && scroll_speed + xscroll < xscroll {
            scroll_speed = ($FF - xscroll) + 1
        }
        playerx -= scroll_speed
        //scroll the screen as well
        scrolling_right = true
        scrolling_left = false
    }
    else if playerx < $78 && not(current_screen == 0 && xscroll == 0) {
        // playerx = $78
        //update the position of the screen sprites
        scroll_speed = $78 - playerx
        if current_screen == 0 && xscroll - scroll_speed > xscroll {
            scroll_speed = xscroll
        }
        //set screen scroll left limit
        playerx += scroll_speed
        //scroll the screen as well
        scrolling_right = false
        scrolling_left = true
    }
    else {
        scrolling_left = false
        scrolling_right = false
    }

    snap_player_pos_limits()
    update_player_sprites()
}

void irq() {
}

inline void snap_player_pos_limits() {
    //snap the player back to the playable area of the screen
    if playerx > $F0 {
        playerx = $F0
    }
    if playerx < $08 {
        playerx = $08
    }
    if playery > $D0 {
        playery = $D0
        on_ground = true
    }
    if playery < $20 {
        playery = $20
    }
}

void draw_status_bar() {
    //draw the status bar accross both nametables
    byte i
    
    //set ppu address increment to 1 so we can draw the left and right borders
    //(allows us to draw to the nametable in vertical strips rather than horizontal)
    ppu_ctrl = %00000000
    read_ppu_status()
    
    //write to first nametable
    ppu_set_addr(ppu_nametable0+$40)
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($11) //$11 = 'H'
    ppu_write_data($0E) //$0E = 'E'
    ppu_write_data($0A) //$0A = 'A'
    ppu_write_data($15) //$15 = 'L'
    ppu_write_data($1D) //$1D = 'T'
    ppu_write_data($11) //$11 = 'H'
    ppu_write_data($25) //$25 = colon
    ppu_write_data($34) //$34 = full box
    ppu_write_data($34) //$34 = full box
    ppu_write_data($35) //$35 = empty box
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($26) //$26 = lives icon
    ppu_write_data($27) //$26 = multiply icon
    ppu_write_data($03) //$03 = 3
    
    //write to second nametable
    ppu_set_addr(ppu_nametable1+$40)
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($11) //$11 = 'H'
    ppu_write_data($0E) //$0E = 'E'
    ppu_write_data($0A) //$0A = 'A'
    ppu_write_data($15) //$15 = 'L'
    ppu_write_data($1D) //$1D = 'T'
    ppu_write_data($11) //$11 = 'H'
    ppu_write_data($25) //$25 = colon
    ppu_write_data($34) //$34 = full box
    ppu_write_data($34) //$34 = full box
    ppu_write_data($35) //$35 = empty box
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($24) //$24 = sky tile
    ppu_write_data($26) //$26 = lives icon
    ppu_write_data($27) //$26 = multiply icon
    ppu_write_data($03) //$03 = 3
    
    
}

void clear_status_bar() {
    //clear the status bar to all sky tiles
    byte i
    
    //set ppu address increment to 1 so we can draw the left and right borders
    //(allows us to draw to the nametable in vertical strips rather than horizontal)
    ppu_ctrl = %00000000
    read_ppu_status()
    
    ppu_set_addr(ppu_nametable0)
    for i,0,until,$80 {
        ppu_write_data($24) //$24 = sky tile
    }
    
    ppu_set_addr(ppu_nametable1)
    for i,0,until,$80 {
        ppu_write_data($24) //$24 = sky tile
    }
}

void prepare_sprite0() {
    //move sprite0 to overlap with bottom edge
    //of the status bar in preperation for splitting
    //the screen
    oam_buffer[0] = $16
    oam_buffer[1] = $FF
    oam_buffer[2] = $00
    oam_buffer[3] = $08
}

void init_sprites() {
    byte i
    for i,0,to,255 {
        if (i & %00000011) == 0 {
            //each sprite takes up 4 bytes, and we want to edit
            //the y position of each sprite (0th byte)
            //so we use the %00000011 mask to write every 4th byte (every 0th sprite byte)
            
            oam_buffer[i] = $ef // move the sprite off screen
        }
        else {
            oam_buffer[i] = 0
        }
    }
}

void load_palletes() {
    byte i
    read_ppu_status() // read PPU status to reset the high/low latch
    ppu_set_addr(ppu_pallete_ram) // point the PPU to palette ram
    for i,0,until,$20 {
        ppu_write_data(pallete[i])
    }
}

void update_player_sprites() {
    oam_buffer[playersprite0_x] = playery
    oam_buffer[playersprite0_tile] = sprite0_tile
    oam_buffer[playersprite0_attrs] = sprite0_attrs
    oam_buffer[playersprite0_y] = playerx
    
    oam_buffer[playersprite1_x] = playery
    oam_buffer[playersprite1_tile] = sprite1_tile
    oam_buffer[playersprite1_attrs] = sprite1_attrs
    oam_buffer[playersprite1_y] = playerx + 8
    
    oam_buffer[playersprite2_x] = playery + 8
    oam_buffer[playersprite2_tile] = sprite2_tile
    oam_buffer[playersprite2_attrs] = sprite2_attrs
    oam_buffer[playersprite2_y] = playerx
    
    oam_buffer[playersprite3_x] = playery + 8
    oam_buffer[playersprite3_tile] = sprite3_tile
    oam_buffer[playersprite3_attrs] = sprite3_attrs
    oam_buffer[playersprite3_y] = playerx + 8
}

const array pallete = [
  $0F,$17,$18,$29,$34,$38,$18,$2A,$38,$39,$3A,$3B,$3C,$3D,$3E,$0F, //nametable palettes
  $3C,$10,$37,$0F,$07,$10,$2D,$0F,$0F,$00,$0F,$36,$31,$02,$38,$3C  //sprite palettes
]

//define each metatile
const array metatiles = [
			//Tile positions:
			//top-left	bot-left	top-right	bot-right
            $24,		$24,		$24,		$24, // 		$00, should always be
                                                     //        all background
            $30,		$31,		$30,		$31, // 		$01, basic top ground tile
            $31,		$31,		$31,		$31, //		$02, all ground tile
            $24,		$32,		$24,		$24, //		$03, floor flower tile
            $24,		$24,		$24,		$33, //		$04, floor grass tile
            $24,		$36,		$24,		$37, //		$05, bushes tile A
            $24,		$30,		$24,		$24 //		$06, single-tile platform
]


//contains 4 screens worth of metatiles
//each metatile column is 16 bytes long
//each metatile column contains 3 bytes of wasted space, two at the top, and one at end
//(this is a holdover from one of my older projects, you could rearange it so that all
//the unused bytes are contiguous, you'd just have to change the loops in the draw_column functions)
const array screen_metatiles = file("levels/level1.bin")

const array attrs = file("graphics/attrib.bin")

segment(chrrom) const array graphics @ $0000 = file("graphics/nesthing.chr")