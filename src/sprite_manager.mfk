struct Sprite { //NES hardware sprite layout
    byte y,         // Y Coordinate - 1
    byte tile,      // tile index #
    byte attrs,     // attributes
    byte x,         // X Coordinate
    bool even       // arbitrary value given to sprites
                    // by whatever object is using them to ensure proper sprite flickering.
                    // The value of this should be alternated 
                    // between the sprites of a metasprite (e.g. sprite0=even,sprite1=odd, etc...)
                    // to ensure sprites flicker properly.
}



array oam_buffer [256] @$200 // sprite buffer

const byte left_stack_lim = $04
const byte right_stack_lim = $FF
byte right_stack //stack variable for the left side of oam_buffer
byte left_stack //stack variable for the right side of oam_buffer
bool even_on_left_stack // Are the even sprites on the queue going on the left or right stack this frame?
                     // this value should be alternated every frame to ensure proper sprite
                     // flickering
byte sprite_queue_num   //number of sprites currently in the queue

array(pointer.Sprite) sprite_queue [63] //63 and not 64 because we never use sprite 0 for anything
                                        //other than screen splitting for the status bar

//player sprite constants
const byte sprite0_attrs = 0
const byte sprite1_attrs = 0
const byte sprite2_attrs = 0
const byte sprite3_attrs = 0
const byte sprite0_tile = 0
const byte sprite1_tile = 1
const byte sprite2_tile = 2
const byte sprite3_tile = 3

void init_sprite_manager() {
    left_stack = left_stack_lim //skip sprite 0
    right_stack = right_stack_lim
    sprite_queue_num = 0
    even_on_left_stack = true
}

void draw_sprites() {
    //Take all the sprites in the queue, and move them
    //to the proper spots in the OAM buffer.
    //After that, prepare for the next time we draw sprites
    //by clearing the sprite queue and alternating the
    //even_on_left_stack variable to ensure sprite flickering
    
    //get the old sprites off the screen
    clear_stacks()
    //write the new sprites
    transfer_queue_to_oam_buffer()
    //clear the queue
    clear_sprite_queue()
    //prepare for the next frame
    even_on_left_stack = not(even_on_left_stack)
}

void clear_sprite_queue() {
    sprite_queue_num = 0
}

void add_sprite_to_queue(pointer addr) {
    sprite_queue[sprite_queue_num] = pointer.Sprite(addr)
    sprite_queue_num += 1
}

void transfer_queue_to_oam_buffer() {
    byte i
    pointer.Sprite spr
    
    for i,0,until,sprite_queue_num {
        spr = sprite_queue[i]
        if even_on_left_stack {
            if spr->even {
                add_to_left_stack(spr)
            }
            else {
                add_to_right_stack(spr)
            }
        }
        else {
            if spr->even {
                add_to_right_stack(spr)
            }
            else {
                add_to_left_stack(spr)
            }
        }
    }
}

inline void add_to_left_stack(pointer.Sprite spr) {
    oam_buffer[left_stack] = spr->y
    oam_buffer[left_stack+1] = spr->tile
    oam_buffer[left_stack+2] = spr->attrs
    oam_buffer[left_stack+3] = spr->x
    
    left_stack += 4
}

inline void add_to_right_stack(pointer.Sprite spr) {
    oam_buffer[right_stack-3] = spr->y
    oam_buffer[right_stack-2] = spr->tile
    oam_buffer[right_stack-1] = spr->attrs
    oam_buffer[right_stack] = spr->x
    
    right_stack -= 4
}

void clear_stacks() {
    clear_left_stack()
    clear_right_stack()
}

inline void clear_left_stack() {
    while left_stack > left_stack_lim {
        left_stack -= 4 //sprites take up 4 bytes in hardware
        oam_buffer[left_stack] = $ef //move the sprite offscreen
    }
}
inline void clear_right_stack() {
    while right_stack < right_stack_lim {
        right_stack += 4 //sprites take up 4 bytes in hardware
        oam_buffer[right_stack-3] = $ef //move the sprite offscreen
    }
}

void init_sprites() {
    byte i
    for i,0,to,255 {
        if (i & %00000011) == 0 {
            //each sprite takes up 4 bytes, and we want to edit
            //the y position of each sprite (0th byte)
            //so we use the %00000011 mask to write every 4th byte (every 0th sprite byte)
            
            oam_buffer[i] = $ef // move the sprite off screen
        }
        else {
            oam_buffer[i] = 0
        }
    }
}

void prepare_sprite0() {
    //move sprite0 to overlap with bottom edge
    //of the status bar in preparation for splitting
    //the screen
    oam_buffer[0] = $16
    oam_buffer[1] = $FF
    oam_buffer[2] = $00
    oam_buffer[3] = $08
}

void update_player_sprites() {
    player1_sprites[0].y = player1.pos.y
    player1_sprites[0].tile = sprite0_tile
    player1_sprites[0].attrs = sprite0_attrs
    player1_sprites[0].x = player1.pos.x
    player1_sprites[0].even = true
    
    player1_sprites[1].y = player1.pos.y
    player1_sprites[1].tile = sprite1_tile
    player1_sprites[1].attrs = sprite1_attrs
    player1_sprites[1].x = player1.pos.x + 8
    player1_sprites[1].even = false
    
    player1_sprites[2].y = player1.pos.y + 8
    player1_sprites[2].tile = sprite2_tile
    player1_sprites[2].attrs = sprite2_attrs
    player1_sprites[2].x = player1.pos.x
    player1_sprites[2].even = true
    
    player1_sprites[3].y = player1.pos.y + 8
    player1_sprites[3].tile = sprite3_tile
    player1_sprites[3].attrs = sprite3_attrs
    player1_sprites[3].x = player1.pos.x + 8
    player1_sprites[3].even = false
    
    //now add these sprites to the queue
    add_sprite_to_queue(player1_sprites[0].addr)
    add_sprite_to_queue(player1_sprites[1].addr)
    add_sprite_to_queue(player1_sprites[2].addr)
    add_sprite_to_queue(player1_sprites[3].addr)
}